{"version":3,"sources":["CzMask.js"],"names":["CzMask","opt","el","_infoKey","event","keyData","code","keyCode","which","isDel","isSup","_czmask","preventDefault","target","mask","dataset","cursor","selectionStart","value","split","arrMask","positionCursor","fixedChars","Object","keys","reduce","result","item","forEach","char","splice","indexOf","initPositionDel","initCursorSup","nextElement","cnt","initPosition","map","ix","join","setSelectionRange","removeEventListener","addEventListener"],"mappings":";AA+FeA,aAAAA,OAAAA,eAAAA,QAAAA,aAAAA,CAAAA,OAAAA,IAAAA,QAAAA,aAAAA,EA/Ff,IAAMA,EAAS,SAACC,GAEV,KADJA,EAAMA,GAAO,IACJC,GAAI,MAAO,GAEdC,IAAAA,EAAW,SAACC,GACZ,IAACA,EAAO,OAAO,EACnBH,EAAII,QAAU,GACdJ,EAAII,QAAQC,KAAOF,EAAMG,SAAWH,EAAMI,MACrB,IAArBP,EAAII,QAAQC,OAAeL,EAAII,QAAQI,OAAQ,GAC1B,KAArBR,EAAII,QAAQC,OAAgBL,EAAII,QAAQK,OAAQ,IAG5CC,EAAU,SAACP,GACX,IAACA,EAAO,OAAO,EACnBA,EAAMQ,iBAEAC,IAAAA,EAAST,EAAMS,OACjB,IAACA,EAAQ,MAAO,GACdC,IAAAA,EAAOb,EAAIa,MAAQD,EAAOE,QAAQD,KAClCE,EAASH,EAAOI,eAEhBC,EAAQL,EAAOK,MAAMC,MAAM,IAC7BC,EAAUN,EAAKK,MAAM,IACrBE,EAAiBL,EAAS,EAGxBM,EAAaC,OAAOC,KACxBJ,EAAQK,OAAO,SAACC,EAAQC,GAEfD,OADPA,EAAOC,GAAQA,EACRD,GACN,KAIDzB,GAdY,CAAC,KAYT2B,QAAQ,SAACC,GAASP,OAAAA,EAAWQ,OAAOR,EAAWS,QAAQF,GAAO,KAElE5B,EAAII,QAAQI,MAEVa,GAAAA,EAAWS,QAAQX,EAAQJ,KAAY,EAAG,CAErCM,IADHU,IAAAA,EAAkBX,EACfC,EAAWS,QAAQX,EAAQC,KAAoB,GACpDA,IAEFA,EAAiBH,EAAMG,GACnBA,IACEW,EACNd,EAAMY,OAAOT,IAAkB,EAAG,UAC7BH,EAAMY,OAAOd,EAAQ,EAAG,UAC1B,GAAIf,EAAII,QAAQK,MAAO,CAE5BQ,EAAMY,OAAOd,EAAQ,EAAG,KAEjBE,IADHe,IAAAA,EAAgBjB,EACbE,EAAMe,IAAgB,CACvBX,IAAgD,IAAhDA,EAAWS,QAAQX,EAAQa,IAAwB,CAG9CX,IAFHY,IAAAA,EAAcD,EAAgB,EAC9BE,EAAM,EACHb,EAAWS,QAAQX,EAAQc,KAAiB,GACjDA,EAAcD,EAAgBE,IAEhCjB,EAAMY,OAAOG,EAAe,EAAGf,EAAMgB,KACa,IAA9CZ,EAAWS,QAAQX,EAAQc,KAC7BhB,EAAMY,OAAOI,EAAa,GAG9BD,SAEG,CAIEX,IADDc,IAAAA,EAAef,EACdC,EAAWS,QAAQX,EAAQC,KAAoB,GACpDA,IAEFH,EAAMG,GAAkBH,EAAMkB,GAC9BlB,EAAMY,OAAOT,EAAiB,EAAG,GAInCD,EAAUA,EAAQiB,IAAI,SAACR,EAAMS,GACvBhB,OAAAA,EAAWS,QAAQF,IAAS,EAAUA,EAC9BX,EAAMoB,IAAOT,IAI3BhB,EAAOK,MAAQE,EAAQmB,KAAK,IAG5B1B,EAAO2B,kBAAkBnB,EAAiB,EAAGA,EAAiB,IAIhEpB,EAAIC,GAAGuC,oBAAoB,QAAStC,GACpCF,EAAIC,GAAGuC,oBAAoB,QAAS9B,GACpCV,EAAIC,GAAGwC,iBAAiB,UAAWvC,GACnCF,EAAIC,GAAGwC,iBAAiB,QAAS/B,IAGpBX,EAAAA,EAAAA,QAAAA,QAAAA","file":"CzMask.js","sourceRoot":"../src","sourcesContent":["const CzMask = (opt) => {\n  opt = opt || {}\n  if (!opt.el) return []\n\n  const _infoKey = (event) => {\n    if (!event) return false\n    opt.keyData = {}\n    opt.keyData.code = event.keyCode || event.which\n    opt.keyData.code === 8 && (opt.keyData.isDel = true)\n    opt.keyData.code === 46 && (opt.keyData.isSup = true)\n  }\n\n  const _czmask = (event) => {\n    if (!event) return false\n    event.preventDefault()\n\n    const target = event.target\n    if (!target) return []\n    const mask = opt.mask || target.dataset.mask\n    const cursor = target.selectionStart\n    const varChar = ['_']\n    const value = target.value.split('')\n    let arrMask = mask.split('')\n    let positionCursor = cursor - 1\n\n    // almacena la lista de caracteres no modificables\n    const fixedChars = Object.keys(\n      arrMask.reduce((result, item) => {\n        result[item] = item\n        return result\n      }, {})\n    )\n    varChar.forEach((char) => fixedChars.splice(fixedChars.indexOf(char), 1))\n\n    if (opt.keyData.isDel) {\n      // captura borrar tecla delete\n      if (fixedChars.indexOf(arrMask[cursor]) >= 0) {\n        let initPositionDel = positionCursor\n        while (fixedChars.indexOf(arrMask[positionCursor]) >= 0) {\n          positionCursor--\n        }\n        positionCursor = value[positionCursor]\n          ? positionCursor\n          : ++initPositionDel\n        value.splice(positionCursor--, 0, '_')\n      } else value.splice(cursor, 0, '_')\n    } else if (opt.keyData.isSup) {\n    // captura borrar tecla suprimir\n      value.splice(cursor, 0, '_')\n      let initCursorSup = cursor\n      while (value[initCursorSup]) {\n        if (fixedChars.indexOf(arrMask[initCursorSup]) === -1) {\n          let nextElement = initCursorSup + 1\n          let cnt = 2\n          while (fixedChars.indexOf(arrMask[nextElement]) >= 0) {\n            nextElement = initCursorSup + cnt++\n          }\n          value.splice(initCursorSup, 0, value[nextElement])\n          if (fixedChars.indexOf(arrMask[nextElement]) === -1) {\n            value.splice(nextElement, 1)\n          }\n        }\n        initCursorSup++\n      }\n    } else {\n      // captura teclas\n      // busca una posiciÃ³n para el nuevo caracter\n      const initPosition = positionCursor\n      while (fixedChars.indexOf(arrMask[positionCursor]) >= 0) {\n        positionCursor++\n      }\n      value[positionCursor] = value[initPosition]\n      value.splice(positionCursor + 1, 1)\n    }\n\n    // remplaza los valores existentes y nuevos en la mascara\n    arrMask = arrMask.map((char, ix) => {\n      if (fixedChars.indexOf(char) >= 0) return char\n      else return value[ix] || char\n    })\n\n    // carga el nuevo valor\n    target.value = arrMask.join('')\n\n    // mueve el cursor\n    target.setSelectionRange(positionCursor + 1, positionCursor + 1)\n  }\n\n  // eventos\n  opt.el.removeEventListener('input', _infoKey)\n  opt.el.removeEventListener('input', _czmask)\n  opt.el.addEventListener('keydown', _infoKey)\n  opt.el.addEventListener('input', _czmask)\n}\n\nexport default CzMask\n"]}